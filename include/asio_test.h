#ifndef ASIO_TEST_H
#define ASIO_TEST_H

#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <ctime>
#include <string>
#include <boost/range.hpp>

#include <boost/bind/bind.hpp>
#include <boost/array.hpp>
#include <boost/uuid/uuid.hpp>

#include <include/functs.h>

#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/serialization/string.hpp>

//avoid naming conflicts with windows functions
#if defined(_WIN32)           
	#define NOGDI             // All GDI defines and routines
	#define NOUSER            // All USER defines and routines
#endif

#include <boost/asio.hpp>


#if defined(_WIN32)           // raylib uses these names as function parameters
	#undef near
	#undef far
#endif

int asio_timer_test();

class recurringTimer
{
   public:
   recurringTimer(boost::asio::io_context& io);
   ~recurringTimer();
   void printMsg(int orange);
   void printMsg2(int orange);

   private:
      int count_ {0};
      int duration_ {1};
      boost::asio::strand<boost::asio::io_context::executor_type> strand_;
      boost::asio::steady_timer timer_;
      boost::asio::steady_timer timer2_;
};

extern std::deque<std::string> receivedDataQueue;
extern std::mutex queueMutex;

class networkInstance
{
   public:
      networkInstance(boost::asio::io_context& dt_io)
         : socket_(dt_io)//initialise socket
         {};
      boost::asio::ip::udp::socket socket_;
      std::shared_ptr<boost::array<char, 2048>> recv_buf = std::make_shared<boost::array<char, 2048>>();
      int syncDTServerUDP(boost::asio::io_context& dt_io);
      int syncDTClientUDP(boost::asio::io_context& dt_io);
      void handleReceive(const boost::system::error_code& error, std::size_t bytesTransferred);
      void sendMessage(std::string header, std::string body);

      const int clientPort {30065};
      const int serverPort {31065};
      boost::asio::ip::udp::endpoint remote_endpoint;

};

class msgHeader
{
   public: 
      //header
      uint32_t size;
      messageType type{M_MISC};
      boost::uuids::uuid entityID{};     //ID of entity
         //ID (which player)
         //Type (what data)
         //Size (Total including header)
      //body
         //char (serialised data)
};


/*
Networking notes:
 - Architecture:
   > Client Hosted

Server Duties:
 - Main 

 - Information generated by the client
 > Client player information
    > Location
    > Status (alternatively handled by the server)
    > Attacks and dependent projectiles/entities
 > Client player required information
    > Enemy information and status

Essentially, for the current setup, it would require:
 - A separate player entity for each player
 - A vector to hold all the players

 - A separate attack deque for each player
 - A vector to hold all attack deques

TODO: 
 - Enable looping of projectiles and player characters for rendering of multiple players
 - Simulate network information inflow through local multiplayer
 - Convert information source to proper network endpoints
*/

#endif