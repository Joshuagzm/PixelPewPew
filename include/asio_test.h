#ifndef ASIO_TEST_H
#define ASIO_TEST_H

#include <iostream>
#include <boost/asio.hpp>
#include <boost/bind/bind.hpp>
#include <boost/array.hpp>
#include <thread>
#include <queue>
#include <mutex>

#include <ctime>
#include <string>

int asio_timer_test();

class recurringTimer
{
   public:
   recurringTimer(boost::asio::io_context& io);
   ~recurringTimer();
   void printMsg(int orange);
   void printMsg2(int orange);

   private:
      int count_ {0};
      int duration_ {1};
      boost::asio::strand<boost::asio::io_context::executor_type> strand_;
      boost::asio::steady_timer timer_;
      boost::asio::steady_timer timer2_;
};

extern std::queue<std::string> receivedDataQueue;
extern std::mutex queueMutex;

void sendMessageLoop();

class networkInstance
{
   public:
      networkInstance(boost::asio::io_context& dt_io)
         : socket_(dt_io)//initialise socket
         {};
      boost::asio::ip::udp::socket socket_;
      std::shared_ptr<boost::array<char, 128>> recv_buf = std::make_shared<boost::array<char, 128>>();
      void syncDTServerUDP(boost::asio::io_context& dt_io);
      void syncDTClientUDP(boost::asio::io_context& dt_io);
      void handleReceive(const boost::system::error_code& error, std::size_t bytesTransferred);

      const int clientPort {30065};
      const int serverPort {31065};
      boost::asio::ip::udp::endpoint remote_endpoint;

};


/*
Networking notes:
 - To implement multiplayer we have options:
    > Peer to peer
    > Server(Hosted)-Client
    > Server(Dedicated)-Client

Peer to peer
 - Due to neutral third party information (enemies, score) it may be hard to synchronise 

Hosted - Client
 - Has a host that holds and generates most of the information, and a dependent client that just
    renders and sends inputs back to the server 
 - Information generated by the server:
 > Enemies
 > Host player information
    > Location
    > Status
    > Attacks and dependent projectiles/entities

 - Information generated by the client
 > Client player information
    > Location
    > Status (alternatively handled by the server)
    > Attacks and dependent projectiles/entities
 > Client player required information
    > Enemy information and status

Essentially, for the current setup, it would require:
 - A separate player entity for each player
 - A vector to hold all the players

 - A separate attack deque for each player
 - A vector to hold all attack deques

TODO: 
 - Enable looping of projectiles and player characters for rendering of multiple players
 - Simulate network information inflow through local multiplayer
 - Convert information source to proper network endpoints
*/

#endif